" vim: set foldlevel=0 foldmethod=marker:

set nocompatible
let mapleader = ","

" Vimscripts {{{
source ~/.vim/bundles.vim
source ~/.vim/keymaps.vim
runtime macros/matchit.vim " match the opening/closign html tag when pressing '%'
" }}}

" Vim options {{{
filetype plugin indent on
syntax on
set encoding=utf-8
set number
set relativenumber
set ignorecase
set smartcase
set infercase
set hlsearch
set incsearch
set smartindent
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
set backspace=indent,eol,start
set wildmenu
set wildmode=full
set mouse=a
set nowrap
set shiftround
set laststatus=2
set nobackup
set noswapfile
set undodir=~/.vim/tmp/undo//
set undofile
set undolevels=1000 "maximum number of changes that can be undone
set undoreload=10000 "maximum number lines to save for undo on a buffer reload
set dictionary=/usr/share/dict/words
set foldmethod=syntax
set nofoldenable
set history=1000
set scrolloff=3 " Leave some ground while scrolling
set bg=dark
set shortmess+=c " Quiet completions
colorscheme badwolf
" }}}

" Highlight {{{
highlight OverLength ctermbg=red ctermfg=white guibg=#592929

" Marks the 81st column of lines wider than 80 characters
function! ShowOverLength()
  if !exists('b:over_length_match')
    let b:over_length_match = matchadd('OverLength', '\v%81v\ze(.+)', 100)
  endif
endfunction

function! HideOverLength()
  if exists('b:over_length_match')
    call matchdelete(b:over_length_match)
    unlet b:over_length_match
  endif
endfunction

augroup Highlight
  autocmd!
  autocmd BufEnter * call ShowOverLength()
augroup END

command HideOverLength call HideOverLength()
command ShowOverLength call ShowOverLength()
" }}}

" CSApprox, for emulating gvim colors on the terminal {{{
if !has('gui_running') && exists(':CSApprox')
  CSApprox
endif

if &term =~ '^\(xterm\|screen\)$' && $COLORTERM == 'gnome-terminal'
  " Number of terminal colors
  set t_Co=256
endif
" }}}

augroup markdown " {{{
  autocmd!

  " Set syntax highlighting for specific file types
  autocmd BufRead,BufNewFile *.md set filetype=markdown
  " Enable spellchecking for Markdown
  autocmd FileType markdown setlocal spell
  " Automatically wrap at 80 characters for Markdown
  autocmd BufRead,BufNewFile *.md setlocal textwidth=80
augroup END " }}}

augroup git " {{{
  autocmd!

  " Automatically wrap at 72 characters and spell check git commit messages
  autocmd FileType gitcommit setlocal textwidth=72
  autocmd FileType gitcommit setlocal spell
  " Automatically closes Fugitive.vim buffers when leaving them
  autocmd BufReadPost fugitive://* set bufhidden=delete
augroup END " }}}

" General auto commands {{{
augroup vimrcEx
  autocmd!
  " When editing a file, always jump to the last known cursor position.
  " Don't do it for commit messages, when the position is invalid, or when
  " inside an event handler (happens when dropping a file on gvim).
  autocmd BufReadPost *
        \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
        \ exe "normal g`\"" |
        \ endif
  " Allow stylesheets and html to autocomplete hyphenated words
  autocmd FileType html,css,scss,sass setlocal iskeyword+=-
  " Remove any trailing whitespace before saving
  autocmd BufWrite * :FixWhitespace
  " Resize splits when the window is resized
  autocmd VimResized * :wincmd =
  " Treat ? as part of names in Ruby
  autocmd FileType ruby setlocal iskeyword+=?
augroup END
" }}}

" Ag as grep {{{
if executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor\ --smart-case
end
" }}}

" Syntastic {{{
let g:syntastic_aggregate_errors = 0
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 2
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
      \ "mode": "passive",
      \ "active_filetypes": [],
      \ "passive_filetypes": [] }

let g:syntastic_error_symbol='✗'
let g:syntastic_style_error_symbol = '✗'
let g:syntastic_style_warning_symbol = '⚠'
let g:syntastic_warning_symbol='⚠'

" Ruby
let g:syntastic_ruby_rubocop_exec = '~/rubocop.sh'
let g:syntastic_ruby_checkers = ['rubocop', 'mri', 'reek']

" Haml
let g:syntastic_haml_checkers = ['haml-lint']
" }}}

" Netrw {{{
let g:netrw_localrmdir='rm -r'
" }}}

" Vim instant markdown {{{
let g:instant_markdown_autostart = 0
" }}}

" Lightline {{{
let g:lightline = {
  \ 'active': {
  \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'readonly', 'filename', 'modified' ] ]
  \ },
  \ 'component': {
  \   'readonly': '%{&readonly?"":""}',
  \   'modified': '%{&filetype=="help"?"":&modified?"+":&modifiable?"":"-"}',
  \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}'
  \ },
  \ 'component_visible_condition': {
  \   'readonly': '(&filetype!="help"&& &readonly)',
  \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))',
  \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
  \ },
  \ 'separator': { 'left': '', 'right': '' },
  \ 'subseparator': { 'left': '', 'right': '' }
  \ }
let g:buftabline_numbers = 1
let g:buftabline_indicators = 1
let g:buftabline_separators = 1
let g:lightline.colorscheme = 'Tomorrow_Night'
" }}}

" Switch {{{
autocmd FileType ruby let b:switch_custom_definitions =
  \ [
  \   {
  \     'validates_\(\w\+\)_of\s\+\(:\w\+\)': 'validates \2, \1: true',
  \     'validates\s\+:\(\w\+\),\s\+\(\w\+\):\s\+true':     'validates_\2_of :\1',
  \   },
  \ ]
" }}}

" Vim test {{{
let g:test#strategy = 'vtr'
" }}}

" Localvimrc  {{{
let g:localvimrc_persistent = 1
let g:localvimrc_sandbox = 0
" }}}

" FZF {{{
" Return a list with all open buffers
function! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

" Handles a MRU search in FZF
function! s:bufopen(e)
  " Exit if no file was picked
  if len(a:e) < 2 | return | endif

  " Fzf sends two lines the first with the key combination used to pick
  " a file and the second with the matched line
  let [key, buffer_line] = a:e[0:1]
  " Extract the buffer number from the matched line
  let buffer_number = matchstr(buffer_line, '^[ 0-9]*')
  " Pick the appropriate command based on the key combination used
  let cmd = get({
        \ 'ctrl-x': 'sbuffer',
        \ 'ctrl-v': 'vertical sbuffer',
        \ 'ctrl-t': 'tabnew | buffer '
        \ }, key, 'buffer')
  " Run the picked command with the matched buffer
  execute cmd . buffer_number
endfunction

" Command to list MRU files
command! FZFMru call fzf#run({
      \ 'source': reverse(<sid>buflist()),
      \ 'sink*': function('<sid>bufopen'),
      \ 'options': '--expect=ctrl-t,ctrl-v,ctrl-x',
      \ 'down': len(<sid>buflist()) + 2
      \ })
" }}}

" Neoterm {{{
let g:neoterm_position = 'vertical'
" }}}

" CtrlSF {{{
let g:ctrlsf_default_root = 'project'
let g:ctrlsf_leading_space = 2
let g:ctrlsf_regex_pattern = 1
" }}}

" Disable standard tComment mappings {{{
let g:tcommentMapLeader1 = ''
let g:tcommentMapLeader2 = ''
" }}}

" Yank Ring {{{
let g:yankring_dot_repeat_yank = 1
let g:yankring_clipboard_monitor = 0
" }}}

" Ultisnips {{{
let g:UltiSnipsUsePythonVersion = 3
" }}}

" ACP {{{
function! GetSnipsInCurrentScope()
  return UltiSnips#SnippetsInCurrentScope()
endfunction

function ExpandSnippetOrTab()
  call UltiSnips#ExpandSnippetOrJump()
  if g:ulti_expand_or_jump_res == 0
    return "\<Tab>"
  else
    return ""
  endif
endfunction

function NextOrExpandSnippet()
  return pumvisible() ? "\<C-n>" : ExpandSnippetOrTab()
endfunction

function BackOrTab()
  return pumvisible() ? "\<C-p>" : "\<Tab>"
endfunction

function MapTab()
  inoremap <silent><tab> <c-r>=NextOrExpandSnippet()<cr>
  inoremap <silent><s-tab> <c-r>=BackOrTab()<cr>
endfunction

let g:acp_behaviorSnipmateLength = 1
let g:acp_behaviorKeywordLength = 1

let g:acp_behaviorUserDefinedFunction = 'AggregateCompletion'
let g:acp_behaviorUserDefinedMeets = 'acp#meetsForKeyword'
let g:acp_completeOption = '.'
let g:acp_enableAtStartup = 1
let g:acp_nextItemMapping = ['<C-n>', '<C-n>']
let g:acp_previousItemMapping = ['<C-p>', '<C-p>']
let g:acp_reverseMappingInReverseMenu = 1

let g:localcomplete#OriginNoteAllBuffers = '[B]'
let g:fuzzywordcompletion_disable_keybinding = 1

highlight Pmenu ctermfg=15 ctermbg=236 guifg=#f8f6f2 guibg=#35322d

" Joins a lot of completions source in one, and displays them altogether
function! AggregateCompletion(start, base)
  let completions = []

  if a:start
    " locate the start of the word
    let line = getline('.')
    let start = col('.') - 1
    while start > 0 && line[start - 1] =~ '\a'
      let start -= 1
    endwhile
    return start
  endif

  " Words in all buffers
  " let from_local_complete = FuzzyWordCompletion(a:start, a:base)
  let from_local_complete = localcomplete#allBufferMatches(a:start, a:base)

  " Words in tmux
  let from_tmux = tmuxcomplete#complete(a:start, a:base)
  " All tags
  let from_tags = better_tags_completion#completion(a:start, a:base)
  " Snippets
  let _from_snippets = GetSnipsInCurrentScope()

  let from_tmux = map(from_tmux, "{ 'word': v:val, 'menu': '[T]' }")
  let from_snippets = []
  for [snippet, description] in items(_from_snippets)
    call add(from_snippets, {'word': snippet, 'menu': '[US] ' . description})
  endfor

  let completions = l9#concat([
        \ from_local_complete, from_tmux, from_tags, from_snippets
        \ ])

  return sort(completions)
endfunction

function! AcpMeetsJava(context)
  return len(a:context) > 2
endfunction

if ! exists('g:acp_behavior')
  let g:acp_behavior = {}
endif

let g:acp_behavior['java'] = [
      \ {
      \   'meets': 'AcpMeetsJava',
      \   'completefunc': 'eclim#java#complete#CodeComplete',
      \   'repeat': 0,
      \   'command': "\<C-X>\<C-O>"
      \ }
      \]

let g:tmuxcomplete#trigger = ''
" }}}

" Gundo {{{
let g:gundo_prefer_python3 = 1
" }}}
